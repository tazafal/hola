#labels Phase-Implementation
Describes how to write a class used to parse the XML and convert it into python objects. 

= Introduction =

This document begins with a short overview on how to extend the classes that parse XML without worrying about how the parsing works. 

= Short Example (Pizza Party) =

Lets say that you have a service (lets call it the Pizza Party Feed) and you want to create modules which work on top of the gdata-python-client library. As with all of the Google Data API feeds, your feed begins with Atom and adds additional elements to represent information unique to your application (like the type of pizza that will be at your party, the number of people you can house, etc.). The atom module will handle parsing for the standard Atom elements, but it's up to you to provide a module to parse the elements specific to your feed (Pizza Party pizza, toppings, etc.). 

Your hypothetical feed has entries that look like this:
{{{
<entry xmlns='http://www.w3.org/2005/Atom' xmlns:p='http://example.com/pizza/1.0'>
  <id>http://www.example.com/pizzaparty/223</id>
  <title type='text'>Pizza at my house!</title>
  <author>
    <name>Joe</name>
    <email>joe@example.com</email>
  </author>
  <content type='text'>
    Join us for a fun filled evening of pizza and games!
  </content>
  <link rel='alternate' type='text/html'
        href='http://www.example.com/joe_user/pizza_at_my_house.html'/>
  <p:pizza toppings='pepperoni, sausage' size='large'>Pepperoni with cheese and 
sausage</p:pizza>
  <p:pizza toppings='mushrooms' size='medium'>Mushroom</p:pizza>
  <p:pizza toppings='ham, pineapple' size='extra large'>Hawaiian</p:pizza>
  <p:capacity>25</p:capacity>
  <p:location>My place.<p:address>123 Imaginary Ln, Sometown MO 63000<p:/address></p:location>
</entry>
}}}
To define classes that parse this XML, we need to begin by defining the classes for the inner elements first. Lets start with the {{{capacity}}} element since it is simple.
{{{
PIZZA_NAMESPACE = 'http://example.com/pizza/1.0'

class Capacity(atom.AtomBase):
  _tag = 'capacity'
  _namespace = PIZZA_NAMESPACE
}}}
That's all we need for capacity. Since this element only has a text node, we don't need to define anything more that it's local tag name and namespace. We do not need to define an __init__ constructor or any other methods because the processing for the XML and the text content is inherited from AtomBase.

Next we define a class for {{{pizza}}} notice that this element has some XML attributes.
{{{
class Pizza(atom.AtomBase):
  _tag = 'pizza'
  _namespace = PIZZA_NAMESPACE
  _attributes = atom.AtomBase._attributes.copy()
  _attributes['toppings'] = 'toppings'
  _attributes['size'] = 'size'
  
  def __init__(self, toppings=None, size=None, text=None, 
      extension_elements=None, extension_attributes=None):
    self.toppings = toppings
    self.size = size
    # Call the constructor function for AtomBase to initialize
    # inherited members.
    atom.AtomBase.__init__(self, extension_elements=extension_elements,
        extension_attributes=extension_attributes, text=text)
}}}